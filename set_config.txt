Instalar bibliotecas:
alt + ctrl + s

vai em project: nome_projeto >> python interpreter >> + >> pesquisar bibliotecas

- Flask
- Flask-Migration >> specify version = 2.5.2
- Flask-Restful
- SQLAlchemy
- Flask-SQLAlchemy
- marshmallow
- Marshmallow-sqlalchemy
- Flask-masrshmallow
- mysqlclient

1- Dentro do __init__.py da pasta api vai ter a principal montagem:
    from flask import Flask
    from flask_restful import Api

    app = Flask(__name__)
    app.config.from_object('config')  # puchando o arquivo config.py

    api = Api(app)

2- crie um arquivo na raiz chamado config.py que vai receber alguma configurações padrões
   isso vai ajudar a separar e deixar mais consolidado a api, o primeiro config é:
        - DEBUG = True

        - Depois vamos configurar o acesso do banco:
            USERNAME = 'root'
            PASSWORD = 'essaeasenha'
            SERVER = 'localhost'
            DB = 'api_flask'
            SQLALCHEMY_DATABASE_URI = f'mysql://{USERNAME}:{PASSWORD}@{SERVER}/{DB}'
            SQLALCHEMY_TRACK_MODIFICATIONS = True

3- Vamos criar um arquivo que vai rodar nossa api, dentro da pasta api cria um arquivo chamado
   run.py:
        from api import app

        if __name__ == "__main__":
            app.run()

4- Dentro de views vamos criar um arquivo chamado curso_views, aqui vamos chamar por exemplo
   o metodo get:
        from flask_restful import Resource
        from api import api


        class CursoList(Resource):
            def get(self):
                return "Olá Mundo"


        api.add_resource(CursoList, '/cursos')

5- Dentro do arquivo __init__.py da pasta api é onde vamos chamar todas as views que criarmos,
   então la dentro:
        - from .views import curso_views

6- Volte la no __init__.py e vamos importar algumas bibliotecas e acrescentar algumas alterações:
    from flask import Flask
    from flask_restful import Api
    from flask_sqlalchemy import SQLAlchemy
    from flask_migrate import Migrate


    app = Flask(__name__)
    app.config.from_object('config')  # puchando o arquivo config.py

    # banco de dados
    db = SQLAlchemy(app)
    # config do db
    migrate = Migrate(app, db)

    api = Api(app)

    from .views import curso_views

7- Vamos em models e criar um arquivo chamado curso_model.py, onde vamos criar a primeira tabela:
       from api import db


        class Curso(db.Model):
            __tablename__ = 'curso'
            id = db.Column(db.Integer, primary_key=True,
                           autoincrement=True, nullable=False)
            nome = db.Column(db.String(50), nullable=False)
            descricao = db.Column(db.String(100), nullable=False)
            data_publicacao = db.Column(db.Date, nullable=False)

8- Sempre que criar um novo arquivo em models tem que colocar no arquivo __init__.py
   da pasta api:
        - from .models import curso_model

9- Como criamos a nova tabela em models temos que criar no banco, ou seja fazer uma migration,
   primeiro você tem que esta dentro da pasta onde esta seu app, depois esta com a venv ativada,
   depois disso configurado no terminal você vai digitar:
    - (venv) C:\Users\borge\OneDrive\Documentos\Repos\API_estruturada_2023\venv\Scripts>set FLASK_APP=api.py

    depois:

    - (venv) C:\Users\borge\OneDrive\Documentos\Repos\API_estruturada_2023>flask db init (Cria uma pasta migration)

    depois:

    - (venv) C:\Users\borge\OneDrive\Documentos\Repos\API_estruturada_2023>flask db migrate (Cria o arquivo migration)

    Agora para criar a tabela execute:

    - (venv) C:\Users\borge\OneDrive\Documentos\Repos\API_estruturada_2023>flask db upgrade

10- Vamos criar o schema para validação do dados, vamos em __init__.py na pasta api e adcionar a biblioteca Marshmallow:
    from flask import Flask
    from flask_restful import Api
    from flask_sqlalchemy import SQLAlchemy
    from flask_migrate import Migrate
    from flask_marshmallow import Marshmallow


    app = Flask(__name__)
    app.config.from_object('config')  # puchando o arquivo config.py

    # banco de dados
    db = SQLAlchemy(app)
    ma = Marshmallow(app)
    # config do db
    migrate = Migrate(app, db)

    api = Api(app)

    from .views import curso_views
    from .models import curso_model

11- Depois de chamar a biblioteca acima vamos na pasta schemas e criar um arquivo curso_schema.py, aqui vamos realizar
    realmente a validação dos dados:
        from api import ma
        from ..models import curso_model
        from marshmallow import fields


        class CursoSchema(ma.SQLAlchemyAutoSchema):
            class Meta:
                model = curso_model.Curso
                load_instance = True
                filds = ('id', 'nome', 'descricao', 'data_publicacao')

            nome = fields.String(required=True)
            descricao = fields.String(required=True)
            data_publicacao = fields.Date(required=True)

12- Depois vamos na pasta entidade e criar um arquivo curso.py:
        class Curso():
            def __int__(self, nome, descricao, data_publicacao):
                self.__nome = nome
                self.__descricao = descricao
                self.__data_publicacao = data_publicacao

            @property
            def nome(self):
                return self.__nome

            @nome.setter
            def nome(self, nome):
                self.__nome = nome

            @property
            def descricao(self):
                return self.__descricao

            @nome.setter
            def nome(self, descricao):
                self.__descricao = descricao

            @property
            def data_publicacao(self):
                return self.__data_publicacao

            @nome.setter
            def nome(self, data_publicacao):
                self.__data_publicacao = data_publicacao

13- Agora vamos criar um arquivo chamado curso_service.py na pasta service, ela vai ser usada para o arquivo
    se comunicar diretamento com SQLAlchimy:
        from ..models import curso_model
        from api import db


        def cadatrar_curso(curso):
            curso_bd = curso_model.Curso(nome=curso.nome,
                                         descricao=curso.descricao,
                                         data_publicacao=curso.data_publicacao)
            db.session.add(curso_bd)
            db.session.commit()
            return curso_bd

14- Depois de todas as configurações feitas anteriores vamos focar em dois arquivos, o __init__.py e o
    curso_views.py para começar a criar o CRUD, cadastrando curso.

15- Para cadastrar o curso vamo em curso_views.py e importa:
        - from ..schemas import curso_schema
        - from flask import request, make_response, jsonify
        - from ..entidades import curso
        - from ..services import curso_service

    Agora vamos criar nossas funções para cadastras com o metodo post:
        class CursoList(Resource):
        def get(self):
            return "Olá Mundo"

        # cadastrar
        def post(self):
            # validar a tipagem do input
            cs = curso_schema.CursoSchema()
            validate = cs.validate(request.json)

            # se tiver erro
            if validate:
                return make_response(jsonify(validate), 400)
            else:
                nome = request.json["nome"]
                descricao = request.json["descricao"]
                data_publicacao = request.json["data_publicacao"]

                novo_curso = curso.Curso(nome=nome,
                                         descricao=descricao,
                                         data_publicacao=data_publicacao)
                resultado = curso_service.cadatrar_curso(novo_curso)
                x = cs.jsonify(resultado)

                return make_response(x, 201)

16- Vamos listar os dados no banco, dentro de curso_service.py crie uma função que vai chamar esses dados:
        def listar_cursos():
        cursos = curso_model.Curso.query.all()
        return cursos

        - Depois vai em curso_views.py e na função get que já existe faça alteração chamando a lista_cursos:
                def get(self):
                    cursos = curso_service.listar_cursos()
                    cs = curso_schema.CursoSchema(many=True)
                    return make_response(cs.jsonify(cursos), 200)

17- Vamos implementar listar os cursos por ID, vamos no arquivo curso_service.py e criar uma função:
        def listar_curso(id):
        curso = curso_model.Curso.query.filter_by(id=id).first()
        return curso

18- Depois vamos para o arquivo curso_views.py e criar nova class:
        class CursoDetail(Resource):
            def get(self, id):
                curso = curso_service.listar_curso_id(id)

                if curso is None:
                    return make_response(jsonify("Curso não foi encontrado"), 404)

                cs = curso_schema.CursoSchema()

                return make_response(cs.jsonify(curso), 200)

            def put(self, id):
                pass

            def delete(self, id):
                pass

        - Com isso vamo criar uma nova rota:
            api.add_resource(CursoDetail, '/cursos/<int:id>')

19- Criar uma função de atualização dentro de  curso_views.py e o que ja deixamos preparada antes:
        - Antes la em curso_service.py vamos criar uma fução  que vai fazer essa atualização:
            def atualiza_curso(curso_anterior, curso_novo):
                curso_anterior.nome = curso_novo.nome
                curso_anterior.descricao = curso_novo.descricao
                curso_anterior.data_publicacao = curso_novo.data_publicacao
                db.session.commit()

        - Agora em curso_views.py:
                def put(self, id):
                    curso_bd = curso_service.listar_curso_id(id)

                    if curso_bd is None:
                        return make_response(jsonify("Curso não foi encontrado"), 404)

                    cs = curso_schema.CursoSchema()
                    validate = cs.validate(request.json)  # validar os dados

                    if validate:
                        return make_response(jsonify(validate), 400)
                    else:
                        nome = request.json["nome"]
                        descricao = request.json["descricao"]
                        data_publicacao = request.json["data_publicacao"]

                        novo_curso = curso.Curso(nome=nome,
                                                 descricao=descricao,
                                                 data_publicacao=data_publicacao)

                        curso_service.atualiza_curso(curso_bd, novo_curso)
                        curso_atualizado = curso_service.listar_curso_id(id)

                        return make_response(cs.jsonify(curso_atualizado), 200)

20- Agora so falta o delete para finalizar a primeira parte da API, em curso_service.py cria uma função:
        def remove_curso(curso):
            db.session.delete(curso)
            db.session.commit()

        - Ai lá em curso_views.py vamos criar a função que vai receber o id do curso e chamar a função anterior:
             def delete(self, id):
                curso_bd = curso_service.listar_curso_id(id)

                if curso_bd is None:
                    return make_response(jsonify("Curso não foi encontrado"), 404)

                curso_service.remove_curso(curso_bd)

                return make_response(jsonify("Curso excluido com sucesso"), 204)

21- A PARTIR DAQUI VAMOS FAZER RELACIONAMENTO ENTRE AS TABELAS

22- Para começar vamos em entidade e criar um novo arquivo chamado formacao.py:
        class Formacao():
            def __init__(self, nome, descricao):
                self.__nome = nome
                self.__descricao = descricao

            @property
            def nome(self):
                return self.__nome

            @nome.setter
            def nome(self, nome):
                self.__nome = nome

            @property
            def descricao(self):
                return self.__descricao

            @descricao.setter
            def descricao(self, descricao):
                self.__descricao = descricao

23- Agora vamos a pasta models e criar um arquivo chamado formacao_model.py, criar a tabela no banco:
        from api import db


        # criar tabela
        class Formacao(db.Model):
            __tablename__ = 'curso'
            id = db.Column(db.Integer, primary_key=True,
                           autoincrement=True, nullable=False)
            nome = db.Column(db.String(50), nullable=False)
            descricao = db.Column(db.String(100), nullable=False)

24- Na pasta schema crie um arquivo chamado formacao_schema.py:
        from api import ma
        from ..models import formacao_model
        from marshmallow import fields


        class FormacaoSchema(ma.SQLAlchemyAutoSchema):
            class Meta:
                model = formacao_model.Formacao
                load_instance = True
                filds = ('id', 'nome', 'descricao')

            nome = fields.String(required=True)
            descricao = fields.String(required=True)

25- Agora para pasta services crie o arquivo chamado  fomacao_service.py:
    from ..models import formacao_model
    from api import db


    def cadatrar_formacao(formacao):
        formacao_bd = formacao_model.Formacao(nome=formacao.nome,
                                           descricao=formacao.descricao)
        db.session.add(formacao_bd)
        db.session.commit()
        return formacao_bd


    def listar_formacao():
        formacao = formacao_model.Formacao.query.all()
        return formacao


    def listar_formacao_id(id):
        formacao = formacao_model.Formacao.query.filter_by(id=id).first()
        return formacao


    def atualiza_formacao(formacao_anterior, formacao_novo):
        formacao_anterior.nome = formacao_novo.nome
        formacao_anterior.descricao = formacao_novo.descricao
        db.session.commit()
        return "Curso atualizado com sucesso"


    def remove_formacao(formacao):
        db.session.delete(formacao)
        db.session.commit()

26- Na pasta views cria um arquivo chamado formacao_views.py:
        from flask_restful import Resource
        from api import api
        from ..schemas import formacao_schema
        from flask import request, make_response, jsonify
        from ..entidades import formacao
        from ..services import formacao_service


        class FormacaoList(Resource):
            def get(self):
                formacoes = formacao_service.listar_formacoes()
                fs = formacao_schema.FormacaoSchema(many=True)
                return make_response(fs.jsonify(formacoes), 200)

            # cadastrar
            def post(self):
                # validar a tipagem do input
                fs = formacao_schema.FormacaoSchema()
                validate = fs.validate(request.json)

                # se tiver erro
                if validate:
                    return make_response(jsonify(validate), 400)
                else:
                    nome = request.json["nome"]
                    descricao = request.json["descricao"]

                    nova_formacao = formacao.Formacao(nome=nome,
                                                      descricao=descricao)
                    resultado = formacao_service.cadatrar_formacao(nova_formacao)
                    x = fs.jsonify(resultado)

                    return make_response(x, 201)


        class FormacaoDetail(Resource):
            def get(self, id):
                formacao = formacao_service.listar_formacao_id(id)

                if formacao is None:
                    return make_response(jsonify("Formação não foi encontrado"), 404)

                cs = formacao_schema.FormacaoSchema()

                return make_response(cs.jsonify(formacao), 200)

            def put(self, id):
                formacao_bd = formacao_service.listar_formacao_id(id)

                if formacao_bd is None:
                    return make_response(jsonify("Formação não foi encontrado"), 404)

                fs = formacao_schema.FormacaoSchema()
                validate = fs.validate(request.json)  # validar os dados

                if validate:
                    return make_response(jsonify(validate), 400)
                else:
                    nome = request.json["nome"]
                    descricao = request.json["descricao"]

                    nova_formacao = formacao.Formacao(nome=nome,
                                                      descricao=descricao)

                    formacao_service.atualiza_formacao(formacao_bd, nova_formacao)
                    formacao_atualizado = formacao_service.listar_formacao_id(id)

                    return make_response(fs.jsonify(formacao_atualizado), 200)

            def delete(self, id):
                formacao_bd = formacao_service.listar_curso_id(id)

                if formacao_bd is None:
                    return make_response(jsonify("Formação não foi encontrado"), 404)

                formacao_service.remove_formacao(formacao_bd)

                return make_response(jsonify("Formação excluido com sucesso"), 204)


        api.add_resource(FormacaoList, '/formacoes')
        api.add_resource(FormacaoDetail, '/formacoes/<int:id>')

27- Antes de testar vamos vazer uma alteração no __ini__.py da pasta raiz api, chamando o formacao_views e
    formacao_model:
        from flask import Flask
        from flask_restful import Api
        from flask_sqlalchemy import SQLAlchemy
        from flask_migrate import Migrate
        from flask_marshmallow import Marshmallow


        app = Flask(__name__)
        app.config.from_object('config')  # puchando o arquivo config.py

        # banco de dados
        db = SQLAlchemy(app)
        ma = Marshmallow(app)
        # config do db
        migrate = Migrate(app, db)

        api = Api(app)

        from .views import curso_views, formacao_views
        from .models import curso_model, formacao_model

28- Para que crie a nova tabela vamos ter que rodar a migration, abra o prompt vai na pasta do projeto:
        - cd C:\Users\borge\OneDrive\Documentos\Repos\Github\API_Cursos\venv\Scripts
            - activate (para rodar o venv)

        - Volte ate a pasta raiz:
            - (venv) C:\Users\borge\OneDrive\Documentos\Repos\Github\API_Cursos
                - set FLASK_APP=api.py (Windowns) ou export FLASK_APP=api.py (Linux)

            - (venv) C:\Users\borge\OneDrive\Documentos\Repos\Github\API_Cursos
                - flask db migrate (digite no terminal para roda o migrate)
                - flask db upgrade (digite no terminal para criar tabelas)

29- Agora vamo criar uma relação entre as duas tabelas, o famoso 1 --> * ou * <-- 1, e o primeiro passo
    é ir na pasta models e começar a criar esse relacionamento pelo arquivo curso_model.py:
        from api import db
        from ..models import formacao_model


        # criar tabela
        class Curso(db.Model):
            __tablename__ = 'curso'
            id = db.Column(db.Integer, primary_key=True,
                           autoincrement=True, nullable=False)
            nome = db.Column(db.String(50), nullable=False)
            descricao = db.Column(db.String(100), nullable=False)
            data_publicacao = db.Column(db.Date, nullable=False)

            formacao_id = db.Column(db.Integer, db.ForeignKey("formacao.id"))
            formacao = db.relationship(formacao_model.Formacao, backref=db.backref("cursos",
                                                                                   lazy="dynamic"))


30- Vamos na pasta entidade no arquivo curso.py e vamos adcionar formação na class:
        class Curso():
            def __init__(self, nome, descricao, data_publicacao, formacao):
                self.__nome = nome
                self.__descricao = descricao
                self.__data_publicacao = data_publicacao
                self.__formacao = formacao

            @property
            def nome(self):
                return self.__nome

            @nome.setter
            def nome(self, nome):
                self.__nome = nome

            @property
            def descricao(self):
                return self.__descricao

            @descricao.setter
            def descricao(self, descricao):
                self.__descricao = descricao

            @property
            def data_publicacao(self):
                return self.__data_publicacao

            @data_publicacao.setter
            def data_publicacao(self, data_publicacao):
                self.__data_publicacao = data_publicacao

            @property
            def formacao(self):
                return self.__formacao

            @formacao.setter
            def formacao(self, formacao):
                self.__formacao = formacao

31- Na pasta schema vamos adicionar o campo formacao la no arquivo curso_schema.py:
        from api import ma
        from ..models import curso_model
        from marshmallow import fields


        class CursoSchema(ma.SQLAlchemyAutoSchema):
            class Meta:
                model = curso_model.Curso
                load_instance = True
                filds = ('id', 'nome', 'descricao', 'data_publicacao', 'formacao')

            nome = fields.String(required=True)
            descricao = fields.String(required=True)
            data_publicacao = fields.Date(required=True)
            formacao = fields.String(required=True)

32- Em services no arquivo curso_service.py tambem vamo fazer essa adição de formação:
        from ..models import curso_model
        from api import db


        def cadatrar_curso(curso):
            curso_bd = curso_model.Curso(nome=curso.nome,
                                         descricao=curso.descricao,
                                         data_publicacao=curso.data_publicacao,
                                         formacao=curso.formacao)
            db.session.add(curso_bd)
            db.session.commit()
            return curso_bd


        def listar_cursos():
            cursos = curso_model.Curso.query.all()
            return cursos


        def listar_curso_id(id):
            curso = curso_model.Curso.query.filter_by(id=id).first()
            return curso


        def atualiza_curso(curso_anterior, curso_novo):
            curso_anterior.nome = curso_novo.nome
            curso_anterior.descricao = curso_novo.descricao
            curso_anterior.data_publicacao = curso_novo.data_publicacao
            curso_anterior.formacao = curso_novo.formacao
            db.session.commit()
            return "Curso atualizado com sucesso"


        def remove_curso(curso):
            db.session.delete(curso)
            db.session.commit()

33- Depois que fazer essa alterações vamos rodar o migrate para cirar as alterações:
        - cd C:\Users\borge\OneDrive\Documentos\Repos\Github\API_Cursos\venv\Scripts
            - activate (para rodar o venv)

        - Volte ate a pasta raiz:
            - (venv) C:\Users\borge\OneDrive\Documentos\Repos\Github\API_Cursos
                - set FLASK_APP=api.py (Windowns) ou export FLASK_APP=api.py (Linux)

            - (venv) C:\Users\borge\OneDrive\Documentos\Repos\Github\API_Cursos
                - flask db migrate (digite no terminal para roda o migrate)
                - flask db upgrade (digite no terminal para criar tabelas)

34- Agora vamos cadastrar o curso com a formação, com a logica criada acima iremos no curso_views.py
    para alterar algumas coisas:
        from flask_restful import Resource
        from api import api
        from ..schemas import curso_schema
        from flask import request, make_response, jsonify
        from ..entidades import curso
        from ..services import curso_service, formacao_service  # Chama formacao_service


        class CursoList(Resource):
            def get(self):
                cursos = curso_service.listar_cursos()
                cs = curso_schema.CursoSchema(many=True)
                return make_response(cs.jsonify(cursos), 200)

            # cadastrar
            def post(self):
                # validar a tipagem do input
                cs = curso_schema.CursoSchema()
                validate = cs.validate(request.json)

                # se tiver erro
                if validate:
                    return make_response(jsonify(validate), 400)
                else:
                    nome = request.json["nome"]
                    descricao = request.json["descricao"]
                    data_publicacao = request.json["data_publicacao"]
                    formacao = request.json["formacao"]  # Puxando do curso.py (entidade)

                    # Para listar a formação vamos chamar o id que retorna em formacao
                    formacao_curso = formacao_service.listar_formacao_id(formacao)

                    if formacao_curso is None:
                        return make_response(jsonify("Formação não encontrada!!!"), 404)

                    novo_curso = curso.Curso(nome=nome,
                                             descricao=descricao,
                                             data_publicacao=data_publicacao,
                                             formacao=formacao_curso)  # Add formacao=formacao_curso
                    resultado = curso_service.cadatrar_curso(novo_curso)
                    x = cs.jsonify(resultado)

                    return make_response(x, 201)


        class CursoDetail(Resource):
            def get(self, id):
                curso = curso_service.listar_curso_id(id)

                if curso is None:
                    return make_response(jsonify("Curso não foi encontrado"), 404)

                cs = curso_schema.CursoSchema()

                return make_response(cs.jsonify(curso), 200)

            def put(self, id):
                curso_bd = curso_service.listar_curso_id(id)

                if curso_bd is None:
                    return make_response(jsonify("Curso não foi encontrado"), 404)

                cs = curso_schema.CursoSchema()
                validate = cs.validate(request.json)  # validar os dados

                if validate:
                    return make_response(jsonify(validate), 400)
                else:
                    nome = request.json["nome"]
                    descricao = request.json["descricao"]
                    data_publicacao = request.json["data_publicacao"]

                    formacao = request.json["formacao"]  # Puxando do curso.py (entidade)

                    # Para listar a formação vamos chamar o id que retorna em formacao
                    formacao_curso = formacao_service.listar_formacao_id(formacao)

                    novo_curso = curso.Curso(nome=nome,
                                             descricao=descricao,
                                             data_publicacao=data_publicacao,
                                             formacao=formacao_curso)  # Add formacao=formacao_curso

                    curso_service.atualiza_curso(curso_bd, novo_curso)
                    curso_atualizado = curso_service.listar_curso_id(id)

                    return make_response(cs.jsonify(curso_atualizado), 200)

            def delete(self, id):
                curso_bd = curso_service.listar_curso_id(id)

                if curso_bd is None:
                    return make_response(jsonify("Curso não foi encontrado"), 404)

                curso_service.remove_curso(curso_bd)

                return make_response(jsonify("Curso excluido com sucesso"), 204)


        api.add_resource(CursoList, '/cursos')
        api.add_resource(CursoDetail, '/cursos/<int:id>')

35- Vamos cursos de uma formação, ou seja, iremos colocar dentro de formação os cursos que fazem parte
    do tipo de formação. Vamos em formacao_schema.py para adicionar o curso_schema e fazer essa relação:
        from api import ma
        from ..models import formacao_model
        from marshmallow import fields
        from ..schemas import curso_schema  # <====


        class FormacaoSchema(ma.SQLAlchemyAutoSchema):
            class Meta:
                model = formacao_model.Formacao
                load_instance = True
                fields = ('id', 'nome', 'descricao', 'cursos')  # <==== add cursos (nome do array)

            nome = fields.String(required=True)
            descricao = fields.String(required=True)
            # Aqui vamo pegar todos os cursos e listar eles só pelo id e nome # <====
            cursos = fields.List(fields.Nested(curso_schema.CursoSchema, only=('id', 'nome')))

            - Retorno:
                 {
                    "cursos": [
                        {
                            "id": 1,
                            "nome": "Curso Python Nivel 1"
                        }
                    ],
                    "descricao": "Focado emanalise de dados para programadores",
                    "id": 1,
                    "nome": "Analise de Dados"
                }

36- Vamos criar uma relação de N ---> N, um relação com professor do curso com o tipo de formação. Para isso
    vai na pasta entidade e crie um novo arquivo chamado professor.py:
        class Professor():
        def __init__(self, nome, idade, titulo):
            self.__nome = nome
            self.__idade = idade
            self.__titulo = titulo

        @property
        def nome(self):
            return self.__nome

        @nome.setter
        def nome(self, nome):
            self.__nome = nome

        @property
        def idade(self):
            return self.__idade

        @idade.setter
        def idade(self, idade):
            self.__idade = idade

        @property
        def titulo(self):
            return self.__titulo

        @titulo.setter
        def titulo(self, titulo):
            self.__titulo = titulo

37- Agora na pasta model criar o arquivo professor_model.py para criar o esqueleto do banco:
    from api import db


    # criar tabela
    class Formacao(db.Model):
        __tablename__ = 'professor'
        id = db.Column(db.Integer, primary_key=True,
                       autoincrement=True, nullable=False)
        nome = db.Column(db.String(50), nullable=False)
        idade = db.Column(db.integer, nullable=False)
        titulo = db.Column(db.String(50), nullable=True)

38- Na pasta schema vamos criar o arquvio professor_schema.py:
    from api import ma
    from ..models import professor_model
    from marshmallow import fields


    class ProfessorSchema(ma.SQLAlchemyAutoSchema):
        class Meta:
            model = professor_model.Professor
            load_instance = True
            fields = ('id', 'nome', 'idade', 'titulo')

        nome = fields.String(required=True)
        idade = fields.Integer(required=True)
        titulo = fields.String(required=True)

39- Na pasta services e criar o arquivo professor_service.py:
        from ..models import professor_model
        from api import db


        def cadatrar_professor(professor):
            professor_bd = professor_model.Professor(nome=professor.nome,
                                                     idade=professor.idade,
                                                     titulo=professor.titulo)
            db.session.add(professor_bd)
            db.session.commit()
            return professor_bd


        def listar_professores():
            professores = professor_model.Professor.query.all()
            return professores


        def listar_formacao_id(id):
            professor = professor_model.Professor.query.filter_by(id=id).first()
            return professor


        def atualiza_professor(professor_anterior, professor_novo):
            professor_anterior.nome = professor_novo.nome
            professor_anterior.idade = professor_novo.idade
            professor_anterior.titulo = professor_novo.titulo
            db.session.commit()
            return "Curso atualizado com sucesso"


        def remove_professor(professor):
            db.session.delete(professor)
            db.session.commit()

40- Agora na pasta views crie um arquivo chamdo professor_views.py:
        from flask_restful import Resource
        from api import api
        from ..schemas import professor_schema
        from flask import request, make_response, jsonify
        from ..entidades import professor
        from ..services import professor_service


        class ProfessorList(Resource):
            def get(self):
                professores = professor_service.listar_professores()
                ps = professor_schema.ProfessorSchema(many=True)
                return make_response(ps.jsonify(professores), 200)

            # cadastrar
            def post(self):
                # validar a tipagem do input
                ps = professor_schema.ProfessorSchema()
                validate = ps.validate(request.json)

                # se tiver erro
                if validate:
                    return make_response(jsonify(validate), 400)
                else:
                    nome = request.json["nome"]
                    idade = request.json["idade"]
                    titulo = request.json["titulo"]

                    novo_professor = professor.Professor(nome=nome,
                                                         idade=idade,
                                                         titulo=titulo)
                    resultado = professor_service.cadatrar_professor(novo_professor)
                    x = ps.jsonify(resultado)

                    return make_response(x, 201)


        class ProfessorDetail(Resource):
            def get(self, id):
                professor = professor_service.listar_professor_id(id)

                if professor is None:
                    return make_response(jsonify("Professor não foi encontrado"), 404)

                ps = professor_schema.ProfessorSchema()

                return make_response(ps.jsonify(professor), 200)

            def put(self, id):
                professor_bd = professor_service.listar_professor_id(id)

                if professor_bd is None:
                    return make_response(jsonify("Professor não foi encontrado"), 404)

                ps = professor_schema.ProfessorSchema()
                validate = ps.validate(request.json)  # validar os dados

                if validate:
                    return make_response(jsonify(validate), 400)
                else:
                    nome = request.json["nome"]
                    idade = request.json["idade"]
                    titulo = request.json["titulo"]

                    novo_professor = professor.Professor(nome=nome,
                                                         idade=idade,
                                                         titulo=titulo)

                    professor_service.atualiza_professor(professor_bd, novo_professor)
                    professor_atualizado = professor_service.listar_professor_id(id)

                    return make_response(ps.jsonify(professor_atualizado), 200)

            def delete(self, id):
                professor_bd = professor_service.listar_professor_id(id)

                if professor_bd is None:
                    return make_response(jsonify("Professor não foi encontrado"), 404)

                professor_service.remove_professor(professor_bd)

                return make_response(jsonify("Professor excluido com sucesso"), 204)


        api.add_resource(ProfessorList, '/professores')
        api.add_resource(ProfessorDetail, '/professores/<int:id>')

41- Vai em __init__.py na pasta da api add professor_views e professor_model:
        from flask_restful import Api
        from flask_sqlalchemy import SQLAlchemy
        from flask_migrate import Migrate
        from flask_marshmallow import Marshmallow


        app = Flask(__name__)
        app.config.from_object('config')  # puchando o arquivo config.py

        # banco de dados
        db = SQLAlchemy(app)
        ma = Marshmallow(app)
        # config do db
        migrate = Migrate(app, db)

        api = Api(app)

        from .views import curso_views, formacao_views, professor_views <===
        from .models import curso_model, formacao_model, professor_model <===

42- Depois de todas essas configurações vamos fazer o migration, siga os passos:
        - Ative o ambiente virtual no prompt

        - Rode:
            (venv) c:\Users\borge\OneDrive\Documentos\Repos\Github\API_Cursos>
                - set FLASK_APP=api.
                - flask db migrate
                - flask db upgrade

43- Vamos criar o relacionamento da tabela professores para tabela de formação como N ---> N.
    Para isso vamos fazer novas configurações nos arquivos dentro da pasta model, o formacao_model e
    professor_model:

        - Vamos no arquivo formacao_model.py primeiro:
            from api import db
            from .professor_model import Professor

            # Criação da tabela que vai fazer a ligação entre professor e formacao
            professor_formcao = db.Table('professor_formacao',
                                         db.Column('professor_id', db.Integer,
                                                   db.ForeignKey('professor.id'),
                                                   primary_key=True, nullable=False),
                                         db.Column('formacao_id', db.Integer,
                                                   db.ForeignKey('formacao.id'),
                                                   primary_key=True, nullable=False))


            # criar tabela
            class Formacao(db.Model):
                __tablename__ = 'formacao'
                id = db.Column(db.Integer, primary_key=True,
                               autoincrement=True, nullable=False)
                nome = db.Column(db.String(50), nullable=False)
                descricao = db.Column(db.String(100), nullable=False)
                professor = db.relationship(Professor,
                                            secondary='professor_formacao',  # Faz a ligação com a nova tabela
                                            back_populates='formacoes')  # Onde os dados vão ser puxados

        - Agora vamos no arquivo professor_model:
            from api import db


            # criar tabela
            class Professor(db.Model):
                __tablename__ = 'professor'
                id = db.Column(db.Integer, primary_key=True,
                               autoincrement=True, nullable=False)
                nome = db.Column(db.String(50), nullable=False)
                idade = db.Column(db.Integer, nullable=False)
                titulo = db.Column(db.String(50), nullable=True)
                professor = db.relationship("Formacao",  # Como foi criado a relação dentro do formacao_model, fica assim
                                            secondary='professor_formacao',  # Faz a ligação com a nova tabela
                                            back_populates='professores')  # Onde os dados vão ser puxados

44- Depois de todas essas configurações vamos fazer o migration, siga os passos:
        - Ative o ambiente virtual no prompt

        - Rode:
            (venv) c:\Users\borge\OneDrive\Documentos\Repos\Github\API_Cursos>
                - set FLASK_APP=api.py
                - flask db migrate
                - flask db upgrade

45- Nesse ponto vamos implementar professores em formações, primeira coisa vamos na pasta entidade e abrie o arquivo
    formacao.py:
        class Formacao():
        def __init__(self, nome, descricao, professores):
            self.__nome = nome
            self.__descricao = descricao
            self.__professores = professores <======

        @property
        def nome(self):
            return self.__nome

        @nome.setter
        def nome(self, nome):
            self.__nome = nome

        @property
        def descricao(self):
            return self.__descricao

        @descricao.setter
        def descricao(self, descricao):
            self.__descricao = descricao

       @property                       <======
        def professores(self):
            return self.__professores

        @professores.setter             <======
        def professores(self, professores):
            self.__professores = professores

46- Outro arquivo que temos que mudar é formacao_views.py da pasta views:
        from flask_restful import Resource
        from api import api
        from ..schemas import formacao_schema
        from flask import request, make_response, jsonify
        from ..entidades import formacao
        from ..services import formacao_service


        class FormacaoList(Resource):
            def get(self):
                formacoes = formacao_service.listar_formacoes()
                fs = formacao_schema.FormacaoSchema(many=True)
                return make_response(fs.jsonify(formacoes), 200)

            # cadastrar
            def post(self):
                # validar a tipagem do input
                fs = formacao_schema.FormacaoSchema()
                validate = fs.validate(request.json)

                # se tiver erro
                if validate:
                    return make_response(jsonify(validate), 400)
                else:
                    nome = request.json["nome"]
                    descricao = request.json["descricao"]
                    professores = request.json["professores"] <====

                    nova_formacao = formacao.Formacao(nome=nome,
                                                      descricao=descricao,
                                                      professores=professores)  <====
                    resultado = formacao_service.cadatrar_formacao(nova_formacao)
                    x = fs.jsonify(resultado)

                    return make_response(x, 201)


        class FormacaoDetail(Resource):
            def get(self, id):
                formacao = formacao_service.listar_formacao_id(id)

                if formacao is None:
                    return make_response(jsonify("Formação não foi encontrado"), 404)

                fs = formacao_schema.FormacaoSchema()

                return make_response(fs.jsonify(formacao), 200)

            def put(self, id):
                formacao_bd = formacao_service.listar_formacao_id(id)

                if formacao_bd is None:
                    return make_response(jsonify("Formação não foi encontrado"), 404)

                fs = formacao_schema.FormacaoSchema()
                validate = fs.validate(request.json)  # validar os dados

                if validate:
                    return make_response(jsonify(validate), 400)
                else:
                    nome = request.json["nome"]
                    descricao = request.json["descricao"]
                    professores = request.json["professores"] <= == =

                    nova_formacao = formacao.Formacao(nome=nome,
                                                      descricao=descricao,
                                                      professores=professores) <= == =

                    formacao_service.atualiza_formacao(formacao_bd, nova_formacao)
                    formacao_atualizado = formacao_service.listar_formacao_id(id)

                    return make_response(fs.jsonify(formacao_atualizado), 200)

            def delete(self, id):
                formacao_bd = formacao_service.listar_formacao_id(id)

                if formacao_bd is None:
                    return make_response(jsonify("Formação não foi encontrado"), 404)

                formacao_service.remove_formacao(formacao_bd)

                return make_response(jsonify("Formação excluido com sucesso"), 204)


        api.add_resource(FormacaoList, '/formacoes')
        api.add_resource(FormacaoDetail, '/formacoes/<int:id>')

47- Lá na pasta services abre o arquivo formacao_service.py:
        from ..models import formacao_model
        from api import db
        from .professor_service import listar_professor_id


        def cadatrar_formacao(formacao):
            formacao_bd = formacao_model.Formacao(nome=formacao.nome,
                                                  descricao=formacao.descricao)
            for i in formacao.professores:
                professor = listar_professor_id(i)
                formacao_bd.professores.append(professor)

            db.session.add(formacao_bd)
            db.session.commit()
            return formacao_bd


        def listar_formacoes():
            formacao = formacao_model.Formacao.query.all()
            return formacao


        def listar_formacao_id(id):
            formacao = formacao_model.Formacao.query.filter_by(id=id).first()
            return formacao


        def atualiza_formacao(formacao_anterior, formacao_novo):
            formacao_anterior.nome = formacao_novo.nome
            formacao_anterior.descricao = formacao_novo.descricao

            for i in formacao_novo.professores:  <==============================
                professor = listar_professor_id(i)
                # Adicione verificações aqui
                if professor:
                    # Certifique-se de que a associação não existe antes de adicionar
                    if professor not in formacao_anterior.professores:
                        formacao_anterior.professores.append(professor)

            db.session.commit()
            return "Curso atualizado com sucesso"


            def remove_formacao(formacao):
                db.session.delete(formacao)
                db.session.commit()


48- Em formacao_schema.py na pasta schema mude:
        from api import ma
        from ..models import formacao_model
        from marshmallow import fields
        from ..schemas import curso_schema


        class FormacaoSchema(ma.SQLAlchemyAutoSchema):
            class Meta:
                model = formacao_model.Formacao
                load_instance = True
                fields = ('id', 'nome', 'descricao', 'cursos', 'professores') <==========

            nome = fields.String(required=True)
            descricao = fields.String(required=True)
            # Aqui vamo pegar todos os cursos e listar eles só pelo id e nome
            cursos = fields.List(fields.Nested(curso_schema.CursoSchema, only=('id', 'nome')))

49- Vamos listar os professores, aconteceu um erro que não retona tambem quando faz um PUT e POST de um professor.
    O poblema esta no arquivo formacao_schema.py na pasta schema, vamos retornar todos os registros dentro de formacao:
        from api import ma
        from ..models import formacao_model
        from marshmallow import fields
        from ..schemas import curso_schema, professor_schema  # <======


        class FormacaoSchema(ma.SQLAlchemyAutoSchema):
            professores = ma.Nested(professor_schema.ProfessorSchema, many=True)  # <= Retorna os dados de professores

            class Meta:
                model = formacao_model.Formacao
                load_instance = True
                fields = ('id', 'nome', 'descricao', 'cursos', 'professores')

            nome = fields.String(required=True)
            descricao = fields.String(required=True)
            # Aqui vamo pegar todos os cursos e listar eles só pelo id e nome
            cursos = fields.List(fields.Nested(curso_schema.CursoSchema, only=('id', 'nome')))

50- Vamos implementar paginação na API, para isso vamos na pasta api e criar um arquivo chamado paginate.py:
        from flask import request, url_for


        def paginate(model, schema):
            page = int(request.args.get('page'), 1)
            per_page = int(request.args.get('per_page'), 3)
            page_obj = model.query.paginate(page=page, per_page=per_page)

            next = url_for(
                request.endpoint,
                page=page_obj.next_num if page_obj.has_next else page_obj.page,
                per_page=per_page,
                **request.view_args
            )

            prev = url_for(
                request.endpoint,
                page=page_obj.prev_num if page_obj.has_prev else page_obj.page,
                per_page=per_page,
                **request.view_args
            )

            return {
                'total': page_obj.total,
                'pages': page_obj.pages,
                'next': next,
                'prev': prev,

                'results': schema.dump(page_obj.items)
            }


























